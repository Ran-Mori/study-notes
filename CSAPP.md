#  系统级程序设计

## 1第一次课

### 1.1 一些反常的现象

* x*x当发生越界时有可能会小于零
* **1e20+(-1e20+3.14)**=0

### 1.2 内存溢出错误案例

* 当对struct_s的a[2]进行赋值时会影响b的正确值
* 但当对a[4]及以上赋值时不会错误，因为双精度的double占8字节

```c
typedef struct{
    int a[2];
    double b;
} struct_s
```

### 1.3 练习中的各种意想不到的错误

* for循环不能使用 **unsigned** 作为迭代值，当unsigned为0时减1会变最大

* 字符串末尾有 **\0** ，因此字符串的内存占用比 **char c[strlen(str)]** 大

* 在函数体内声明的 **内存指针** 不能作为返回值的内存指针，因为函数结束后会进行回收。

* 进行宏定义容易出现注入问题

  ```C
  #define IS_GREATER(a,b) a>b
  ```

### 1.4 实用写法

```C
p && *p  //可以防止p空指针
a && 5/a  //可以防止除数为零
```

### 1.5 signed和unsigned的最大最小值

|          | 最大值            | 最小值            |
| -------- | ----------------- | ----------------- |
| unsigned | 11111111 11111111 | 00000000 00000000 |
| signed   | 01111111 11111111 | 10000000 0000000  |

### 1.6 转换规则

* signed会隐试转化为unsigned

*************************



## 第一章

> ### 1.1 信息就是位+上下文
>
> * 只由ASCII码组成的文件称为 **文本文件** ，其他所有文件都称为 **二进制文件** 。 hello.c就是一个文本文件
>
> ***************
>
> ### 1.2  程序被其他程序翻译成不同的格式
>
> * 预处理阶段
>
> > * 预处理器将**#incloude <...>** 中的内容直接作文本替换 
> > * 让main.c文本文件变成另一个文本文件 **main.i**
>
> * 编译阶段
>
> > * 编译器将main.i翻译成文本文件**main.s**
> > * main.s 本质上还是一个文本文件
> > * 只不过文本文件内的内容从高级语言变成了汇编语言
>
> * 汇编阶段
>
> > * 汇编器将main.s翻译成机器语言指令，把这些指令打包成 **relocatable object program** ，把结果保存在**main.o**中
> > * main.o是一个二进制文件不是一个文本文件，用文本编辑器打开会乱码
>
> * 链接阶段
>
> > * main程序调用了**每个C编译器都提供的标准C库中print()函数**
> > * print() 函数存在于一个 **print.o** 的可重定位目标程序中
> > * 链接器要将 **print.o和main.o** 两个 **可重定位目标程序** 合并
> > * 最后得到一个 **main.out或main** 文件
> > * 这是一个可执行文件
>
> *****************
>
> ### 1.4.1系统的硬件组成
>
> * 总线
>
> > * 在各个部件中传输 **字**
> > * 字中的位数( **字长** )是一个系统的重要参数
> > * 32字长就是32位，64字长就是64位
>
> * CPU
>
> > * 寄存器的大小就是这个系统 **字** 的大小，也是 **系统总线** 传输数据单元的大小
>
> *******************
>
> ### 1.4.2运行hello程序
>
> * 键盘输入通过总线传输到寄存器，寄存器再把输入输到内存
> * 回车输入结束后在磁盘中找到目标程序文件，通过DMA将磁盘上的程序文件不经过处理器仅通过总线直接加载入内存
> * CPU执行程序的机器语言指令，将输出字符串从主存复制到寄存器文件，再从寄存器复制到输出设备
>
> ****************
>
> ### 1.5高速缓存至关重要
>
> * 缓存原理——程序的局部性原理
>
> *****************
>
> ### 1.7操作系统管理硬件
>
> > * 所有应用程序对硬件的访问都必须通过 **操作系统**
> > * 操作系统通过向应用程序提供一些简单一致的 **接口** 来控制复杂而通常各不相同的低级硬件设备
> >
> > ***************
>
> > * 文件——**IO** 的抽象
> > * 虚拟内存 —— **主存和IO** 的抽象
> > * 进程 —— **处理器，主存，IO** 的抽象
> >
> > ****************
>
> ****************
>
> ### 1.7.1 进程
>
> * 进程是对一个 **正在运行的程序的一种抽象**
> * 正是因为有了进程的概念，每个程序才能感觉自己是在 **独占** 使用 CPU，主存和IO设备
> * 操作系统切换进程称为 **上下文切换**
> * **上下文** —— 保持跟踪进程运行所需的所有状态信息
> * shell程序执行hello程序涉及到两个进程，涉及进程的切换和控制权的转移
> * 操作系统内核
>
> > * 内核是操作系统代码常驻内存的部分
> > * 当涉及到 **系统调用** 时，将 **控制权** 转交给内核，内核操作完成后在归还控制权
> > * 内核不是一个独立的进程
> > * 内核是系统管理全部进程所有的代码和数据的集合
>
> *******************
>
> ### 1.7.2 线程
>
> * 一个进程可以由多个 **线程** 执行单元组成
> * 线程运行在进程的上下文中
> * 线程共享进程同样的代码和全局数据
> * 多线程比多进程更容易共享数据，也因此效率更高
>
> *******************
>
> ### 1.7.3虚拟内存
>
> * 虚拟内存为进程提供了一个假象 —— 每个进程都在独占地使用主存
> * 每个进程看到的主存都是一致的，称为 **虚拟地址空间**
> * 虚拟地址空间
>
> > * 每个进程看到的虚拟地址空间的结构是 **一模一样** 的
> > * 虚拟地址空间顶层是 **保存的操作系统代码数据** ，是不能动的
> > * 虚拟空间的底层是 **用户进程定义的代码和数据的**
> > * 虚拟地址空间结构(从低地址到高地址)
> >
> > > * 程序代码和数据——就是存放 **可执行目标文件**，示例就是 **main.out或main**
> > > * 堆——调用malloc或free标准库函数动态扩缩的部分
> > > * 共享库——存放C标准库和数学库这种共享代码和数据(实际可能和其他程序映射到同一段物理内存上)
> > > * 栈——位于用户虚拟地址空间的顶部，在顶部就是操作系统内核代码了，编译器用栈来实现函数调用
> > > * 内核虚拟内存——不允许读写，必须通过内核来执行
>
> ### 1.7.4 文件
>
> * **文件就是字节序列**
> * 每个IO设备都是文件
> * 文件最重要的作用是对所有IO都进行了一层抽象，屏蔽了所有的差异而提供了一些统一的接口
>
> ***************
>
> ### 1.9.1 Amdahl定律
>
> * 要想提高整个系统的速度，必须提升全系统中相当大部分的速度
> * 就是说单纯提高一部分的速度好几倍，结果它在整个程序中的占比并不大，最后整个系统速度的提升微乎其微
>
> ***************
>
> ### 1.9.2 并发和并行
>
> * 并发(concurrency)指一个同时具有多个活动的系统
> * 并行(parallelism)指的是通过并发来使一个系统运行得更快
> * 最高层次线程级并发
>
> > * 能够同时执行多个程序时，就导致了并发
> > * 早期的并发是假并发，它只是时间片不停轮转，让用户宏观上看起来像是并发而已。
> > * 通常所说的一个 **核** 就是指一个CPU，八核就是指有8个CPU
> > * 多处理器系统——一个由 **单操作系统内核** 控制的多处理器组成的系统
> > * 高速缓存可以一个核(CPU)独占，也可以所有CPU共享
> > * 超线程(同时多线程)——一项允许一个CPU同时执行多个控制流的技术
> > * 超线程的CPU某些硬件有多个备份，比如PC和register，但其他硬件只有一份
> > * 常规处理器需要20000个时钟周期做线程切换，而超线程处理器可以在一个时钟周期时间内决定执行那个线程，线程切换几乎无感
> > * 多处理器可以从两方面提升系统性能。一是减少了模拟并发的需要，二是多线程运行时能使程序运行得更快
>
> * 中层次指令级并行
>
> > * 指同时执行多条指令
> > * 通过流水线方式执行指令
> > * 当执行指令效率超过 1 instruction per clock 时称为超标量处理器
>
> * 最低层次单指令，多数据(SIMD)并行
>
> > * 一条指令产生多个可以并行执行的操作
> > * 比如并行地对8对浮点数做加法
>
> *********************
>
> ### 1.9.3抽象
>
> * 文件——IO
> * 虚拟内存——IO、主存
> * 进程——IO、主存、处理器
> * 指令集架构——处理器
> * 虚拟机——IO、主存、处理器、**操作系统**

*********************



## 第二章

> ### 2.1.2 字数据大小
>
> * **字长** 决定了 **指针** 的大小，指针的大小决定了最大的寻址范围，因此 **字长决定了虚拟地址空间的大小**
> * 32位最大内存是4GB，64位最大内存是16EB
> * 32位和64位程序的区别——它们两者编译的方式不同。64位编译只能在64位机器上跑，32位编译就都可以跑
> * 在C语言的数据类型上，32位编译方式和64位编译方式的区别在 **long, double, char *** 数据类型大小不同，其他类型数据大小都是相同的
> * 为了避免依赖编译方式，**int32_t , int64_t** 这种数据类型不随编译方式的不同而产生不同的结果
>
> *****************
>
> 
>
> ### 2.1.3 寻址和字节顺序(大小端)
>
> * 最 **低/高** 有效字节在最前面的方式称为 **小/大** 端法
> * 嘤忒尔使用小端法，即最低有效字节在最前面
> * 一般来说操作系统定下来字节顺序就固定下来了，安卓和iOS都使用小端法
>
> *******************
>
> 
>
> ### 2.2 整数表示
>
> * Java只支持有符号数，不支持无符号数
> * **uint32_t** 的实现原理是使用宏
> * 有符号和无符号的转换——**位不变，解释方法不同**
> * 有符号和无符号参与运算时，有符号数会向**无符号**转换
>
> ***************
>
> 
>
> ### 2.2.6数的扩展
>
> * 无符号整数使用 **零扩展**
> * 符号整数使用 **符号扩展**
> * 当同时涉及到 **扩展和类型转换时**，先扩展再类型转换
>
> **********************
>
> 
>
> ### 2.2.7数的截断
>
> * 直接截断，然后按位根据数据类型解释
>
> **************
>
> 
>
> ### 2.3 整数运算
>
> * 反码：正数的反码是本身，负数的反码是除了符号位外全部取反
> * 补码：正数的补码是本身，负数的补码是反码 + 1
> * 负数本身加上负数的补码的和是零，即它们在数学意义上的值互为相反数
> * 无符号加法： 舍弃高位，按无符号解释
> * 符号(补码)加法：舍弃高位，按符号补码解释
> * **补码的非： 就是求补码的相反数，最小值的非是它本身**
>
> ***************
>
> 
>
> ### 2.3.4整数乘法
>
> * 无符号乘法：直接乘，舍弃高位按无符号数解释
> * 补码乘法：首先解释成十进制，按十进制乘在转换为二进制，舍高位按照补码解释
> * **特点：无符号乘法和补码乘法最后舍弃后的位表示是一模一样的**
>
> **************************************
>
> 
>
> ### 2.3.7 除以二的幂
>
> * **高位要进行符号扩展**
> * 不进行任何处理是 **向下舍入**
> * 加上 **偏置** 后是 **向零舍入**，偏置=(1<<k) - 1
>
> **********************
>
> 
>
> ### 2.4.2 IEEE浮点数表示
>
> * 单精度：1 + 8 + 23 
> * 双精度：1 + 11 + 52
> * **Bias值为 (1<<(k-1)-1**
>
> ****************
>
> 

## 第三章

> ### 引言
>
> * 汇编代码是 **机器代码的文本表示形式**
> * GCC调用汇编器和链接器，根据 **汇编代码** 生成可执行的 **机器代码**
> * 汇编代码与CPU指令集耦合，而高级语言不耦合
>
> ****************
>
> 
>
> ### 3.2程序编码
>
> * 机器代码分为两种
>
> > * 目标代码：由汇编器生成，包含所有指令的二进制表示，但还没有填入全局值的地址
> > * 可执行代码：由链接器生成，是处理器执行的代码格式
>
> ******************
>
> 
>
> ### 3.2.1机器级编码
>
> * 两种抽象
>
> > * 指令集架构ISA抽象
> > * 虚拟内存抽象
>
> * 汇编代码就是机器代码可读性更好的文本表示
> * 汇编代码 **不区分有符号，无符号，指针类型，甚至不区分整数和指针**
> * x-86的虚拟内存使用64位寻址，但目前 **最高16位必须设置为0**，因此最大内存为64TB
> * 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的 **物理地址**
>
> *****************
>
> 
>
> ### 3.2.2代码示例
>
> *  生成汇编的指令
>
> ```bash
> gcc -Og -S test.c
> # -Og 使用level0，不进行优化，不然和源代码差距太大
> # -S 只生成汇编文件，不进行链接生成可执行机器代码
> ```
>
> * 机器执行的程序只是一个 **字节序列** ，它是对一系列指令的编码。机器对产生这些指令的源代码几乎 **一无所知**
> * x-86的指令长度 **不统一** ，从1-15字节都有，**越常用指令越短**
> * x-86机器码类似于哈夫曼编码，是 **连续编码可唯一翻译的**
>
> *******************
>
> 
>
> ### 编译指令
>
> * 预处理
>
>   ```bash
>   gcc -E hello.c -o hello.i
>   ```
>
> * 编译
>
>   ```bash
>   gcc -S hello.c -o hello.s
>   ```
>
> * 汇编
>
>   ```bash
>   gcc -c hello.c -o hello.o
>   ```
>
> * 链接
>
>   ```bash
>   gcc hello.c -o hello.out
>   ```
>
> **************
>
> 
>
> ### 3.2.3关于格式的注解
>
> * 编译产生的汇编代码 **以 '.' 开头** 都是知道汇编器和链接器工作的伪指令
> * ATT与Intel汇编代码格式
>
> > * 两者格式不完全相同
> > * Intel版本代码更简略，省略 **%, q, l** 等
> > * **两者涉及多个操作数的情况下顺序是反的，很难顶**
> > * 在 **英特尔和微软** 的官方文档中常用 Intel 格式汇编代码
>
> ***********
>
> 
>
> ### C语言中嵌入汇编的两种方式
>
> * 编写完整函数，放入一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来
> * 使用gcc的内联汇编，在C中直接嵌入汇编代码
>
> **************
>
> 
>
> ### 3.3数据格式
>
> * 由于历史原因，Intel的字大小指 **16位2字节**
>
> * 后缀
>
>   ```bash
>   -b # 1字节，0.5字
>   -l # 4字节，双字
>   -q # 8字节，四字
>   -w # 2字节，一字
>   ```
>
> * 浮点数和整数使用的是 **一组完全不同的指令和寄存器**
>
> *********************
>
> 
>
> ### 3.4访问信息
>
> * 经过实际代码测试，x-86的指针大小为 **64** 位
>
> * 寄存器
>
>   ```bash
>   # 'r'代表64位，'e'代表32位，' '代表16位
>   -rax #返回值
>   -rbx #被调用者保存
>   -rcx #第四个参数
>   -rdx #第三个参数
>   -rsi #第二个参数
>   -rdi #第一个参数
>   -rbp #被调用者保存
>   -rsp #栈指针
>   ```
>
> ******************
>
> 
>
> ### 3.4.1 操作数指示符
>
> * 操作数种类
>
>   ```bash
>   '$0x123FEDB'     #立即数
>   '0x123FEDB'      #内存地址为立即数值的位置的值
>   '%rsp'           #寄存器值
>   '(%rsp)'         #内存地址为寄存器值的位置的值
>   '4(%rsp,%rdi,4)' #内存地址为 '4+%rsp+%rdi*4' 的位置的值
>   ```
>
> 
>
> * 数据传送指令
>
>   ```assembly
>   movzbl 4(%rsp,%rsi,4),%rax # movzbl表示从8位移动到32位，且使用零扩展
>   cltq # 与'movslq %eax,%rax'相同
>   movl # 当只有一个b/w/l/q时是指源的位数是b/w/l/q，与目的地位数无关
>   ```
>
> * 压栈出栈指令
>
>   ```bash
>   # 栈结构特点：栈底地址最高，栈顶地址最低，压栈会使%rsp减少
>   ```
>
> * 算术指令
>
>   ```assembly
>   subq $0x8,%rsp # '%rsp = %rsp - 0x8'。后者为算术操作的第一个数
>   ```
>
> * 加载有效地址 **lea** 指令
>
>   ```assembly
>   movq 7(%rdx,%rdx,4),%rax # 指将内存地址为 '5*%rdx+7' 的值赋值给%rax
>   leap 7(%rdx,%rdx,4),%rax # 指将 '5*%rdx+7' 这个结果赋值给 %rax
>   ```
>
> * 移位指令
>
>   ```assembly
>   shr $0x4,%rdx # sh-shift, r-right 逻辑右移动
>   sar $0x4,%rdx # s-shift, a-arithmetic,r-right
>   ```
>
>   * 逻辑移位：直接移啥都不管
>   * 算数移位：要考虑负数补码符号位
>
> * 乘法指令 **128位**
>
>   ```assembly
>   imulq # 补码乘法
>   mulq  # 无符号数乘法
>       
>   imulq %rdx # %rdx和%rax相乘，生成的128位结果高64位在%rdx，低64位在%rax
>   cqto  # 用于将%rdx设置成%rax的符号位，保证被除数符号统一
>   ```
>
>   * **mulq** 指令必须要求一个操作数位于 **%rax** ，和另一个操作数计算结果高位在%rdx，低位在%rax
>   * **divq** 指令将%rdx和%rax作被除数，操作数作除数，商在%rax，余数在%rdi
>
> ****************
>
> 
>
> ### 3.6.1条件码
>
> * 条件码种类
>
>   ```bash
>   -CF # 进位标志。检测无符号数溢出 
>   -ZF # 零标志。最近操作的结果是0
>   -SF # 符号标志。最近操作结果的符号位
>   -OF # 溢出标志。检测补码溢出
>   ```
>
> * 特性
>
> > * lea 指令不改变任何条件码，其他操作都要改变条件码
> > * cmp 指令相当于 sub 指令，区别是 cmp 只设置条件码
> > * test 指令相当于 and 指令，区别是 test 只设置条件码
>
> * set 指令
>
> > * 操作对象是寄存器的低8位字节，将一个字节设置成0或1
> > * ture和false的确定来源于各个条件码的组合计算
>
> * 跳转指令
>
> > * 无条件直接跳转：给出一个标志，如 'jmp L1'
> > * 无条件间接跳转：'jmp *%rsp' 或 'jmp *(%rsp)'
> > * 其他非 **jmp** 的跳转指令都是条件跳转，且条件跳转 **只能是直接跳转**
> > * PC相对寻址的PC值是 **跳转指令下一条指令的PC值** 而不是跳转指令本身的PC值
> > * **rep** 指令：插入在 **ret** 指令前面，防止直接跳转到ret
> > * 对于布尔值运算，**je** 代表是 **false**
>
> * 条件传送指令
>
> > * 特点：使用条件数据传送代码比条件控制转移代码效率更高，因为现代处理器是基于流水线的
> > * 格式：**cmov**
> > * 执行过程：处理器只读取数据，检查条件码，最后结果要么更新赋值要么保持不变。因此无论预测的结果如何都能保持流水线充满。等于是提前把所有分支结果都算出来
> > * 并不是所有的条件表达式都可以用条件传送来翻译
> > * 条件传送是否提高效率取决于用于额外计算浪费的时间和由于分支预测失误导致流水线爆炸浪费的时间谁更长
>
> *******************
>
> 
>
> ### 3.6.7循环
>
> * while 和 for 循环的两种翻译方法
>
> > * 跳转到中间策略
> > * guarded-do策略
>
> * switch 语句
>
> > * 跳转表
> >   * 本质是一个数组，数组存放的是每种情况跳转的地址
> >   * 跳转表执行开关语句的时间与开关数量无关
> >   * GCC当开关数量比较多，并且值跨度范围小就会使用跳转表
>
> **************
>
> 
>
> ### 3.7过程
>
> * 过程是软件中一种很重要的抽象
> * 过程的形式：函数，方法，子例程等
>
> ***************************
>
> 
>
> ### 3.7.1运行时栈
>
> * 栈帧：一个函数调用的过程占用的栈的所有结构称为栈帧。一个调用就是一个栈帧，且栈顶帧肯定是目前正在执行的函数
> * 栈帧结构。由高地址到低地址，由栈底到栈顶分别是
>   * P保存的寄存器
>   * Q要使用的参数
>   * 返回地址
>
> **********************
>
> 
>
> ### 3.7.2转移控制
>
> * 调用与返回
>
>   ```assembly
>   call # 把 P 过程的下一条指令的地址压入栈，并将 PC 设置成Q过程的起始地址
>   ret  # 从栈中弹出 P 地址，并把 PC 设置成这个地址
>   ```
>
> ***************
>
> 
>
> ### 过程调用执行过程
>
> * P将参数存入到Q能访问的地方
> * P调用Q，并将P的下一条指令地址压栈
> * Q保存P的现场
> * Q读取参数
> * Q为自己的非静态局部变量分配空间
> * Q执行自己的函数体
> * Q释放自己局部变量空间
> * Q恢复P的现场
> * Q将返回值存在P能访问的地方
> * Q返回，将控制权还给P
>
> ### 参数传递
>
> * 当参数数量小于等于6时，可以全部用寄存器传递。最大传递位数为64位
>
> * 当参数数量大于6时必须使用栈来传递，且必须8字节64位对齐。即使是char类型也必须占8字节栈
>
> * 参数压栈是最右边参数先压，也就是说栈顶参数是参数1
>
> * 当参数数量为8时，有如下情况
>
>   ```assembly
>   (%rsp) = location. 指0-7字节
>   16(%rsp) = argu 1. 指16-23字节
>   8(%rsp) = argu 2. 指8-15字节
>   ```
>
> *****************
>
> 
>
> ### 3.7.4栈上的局部存储
>
> * 局部数据也必须存放在栈上的情况
>
> > * 寄存器不足以存放所有的本地数据
> > * 对一个局部变量使用 **&** 运算符时，必须存放到栈上产生一个地址
> > * 数组或者结构变量
>
> * 主函数中调用 **swap_add(&argu1, &argu2)** 过程
>
> > * 栈指针减少16分配空间
> > * (%rsp) 和 8(%rsp) 存放着两个参数的值
> > * 执行函数调用，函数内的操作会对值产生影响
> > * 执行结束后(%rsp) 和 8(%rsp)的值就是操作后的结果
>
> * 在栈上存储数量大于6的参数要8字对齐。但存储局部变量不用局部对齐，可以卡字节来节省空间
>
> ******************
>
> 
>
> ### 3.7.5寄存器中的局部存储空间
>
> * 调用者保存： P调用Q时，必须保证调用P的那一刻和Q返回的那一刻规定寄存器中的值不变
> * 常用的调用者保存策略：
>
> > * 调用前把规定的寄存器值压栈
> > * 压栈后到出栈前的全过程这些寄存器就是自由的
> > * 就可以随便存中间值
>
> *************************
>
> 
>
> ### 3.7.6递归过程
>
> * 用寄存器存储局部变量
>
> ****************
>
> 
>
> ### 3.9结构和联合
>
> * 一个联合总的大小取决于联合中 **最大字段的大小**。即联合数据只能 **n选1**
>
> ****************
>
> 
>
> ### 3.9.3数据对齐
>
> * 对齐原则： 任何K字节对象的地址必须是K的倍数
> * x-86最大对齐就是8字节对齐
> * 当前变量最后实际占用多大空间取决于它的下一个变量怎么对齐

******************************



## 第五章

> ### 序言
>
> * 编译高效程序的几点
>
> > * 选择一组适当的数据结构和算法
> > * 必须编写出编译器能够有效优化以转换为高效可执行的源代码
> > * 一个任务分成多部分，分任务可以在多核和多处理器的机器上并行执行
>
> * 程序优化步骤
>
> > * 消除不必要的工作，如不必要的函数调用、条件测试、内存引用
> > * 了解处理器的运作，操作的时序性。利用处理器提供的指令级并行能力，同时执行多条指令
>
> ***************
>
> 
>
> ### 5.1优化编译器的能力和局限性
>
> * 内存别名使用(Memory aliasing)：两个指针指向同一个内存位置
>
> > * 内存别名使用会使编译器必须假设两个指针有可能相等，因此往往不能采取更高级别的优化
>
> * 函数修改了全局程序状态的一部分
>
> > * 当函数调用执行的次数会对全局程序状态有影响时，往往不能采取更高级别的优化
>
> *****************
>
> 
>
> ### 5.2表示程序的性能
>
> * **CPE**：每元素的周期数。即每增加处理一个元素需要增加多少个时钟周期
>
> *****************
>
> 
>
> ### 5.4消除循环的低效率
>
> * 代码移动(code motion)：比如将循环边界计算出来放在外面而不是每次循环都去计算
>
> *****************
>
> 
>
> ### 5.5消除过程调用
>
> * 在内循环中尽量不要有函数调用
>
> **************
>
> 
>
> ### 5.6消除不必要啊的内存引用
>
> * 求和过程中设置一个中间非指针变量来存储中间结果值，只有在计算出最终结果后才一次性将结果写入result指针处
>
> *************
>
> 
>
> ### 5.7.1整体操作
>
> * 超标量处理器两个部分
>
> > * 指令控制单元(ICU)：负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作
> > * 执行单元(EU)：执行指令
>
> **************

## 第七章

> ### 链接
>
> > #### 定义
> >
> > * 将多个代码和数据片段收集组合成为一个单一文件的过程
> > * 这个单一的文件能够直接加载(复制到内存中执行)
> >
> > #### 可能发生阶段
> >
> > * 编译时
> > * 加载时
> > * 运行时
>
> ### 处理过程
>
> > * 预处理 - ASCII文件
> > * 编译 - ASCII文件
> > * 汇编 - 二进制文件
> > * 链接 - 二进制文件。将多个可重定位的 '.o' 文件链接成一个可执行文件
> >
> > ****************
>
> ### 预处理包括内容
>
> > * 删除 "define" 类的编译判断指令，展开正确条件下的宏
> >
> >   ```c
> >   #define PI = 3.14
> >   ```
> >
> > * 处理 "#ifdef"、"endif" 之类的条件编译，并展开正确条件下的代码
> >
> >   ```c
> >   #ifdef init
> >   code part 1
> >   #else 
> >   code part 2
> >   #endif
> >   ```
> >
> > * 递归添加 "#include"
> >
> > * 删除注释
> >
> > * 添加行号和文件信息，用于报错
> >
> > ****************
>
> ### 链接器的由来
>
> > * 子程序(函数)起始地址和变量的起始地址是 **符号定义**(definition)
> > * 调用子程序(函数)和使用变量是 **符号引用**(reference)
> >
> > ***********
>
> ### 链接操作步骤
>
> > * 符号解析
> >   * 确定符号之间的引用关系
> > * 重定位
> >   * 合并相关的 ".o"文件
> >   * 确定每个符号的值
> >   * 在指令中填入新的地址 (在同一个虚拟地址空间内)
> >
> > *****************
>
> ### 链接的好处
>
> > * 模块化
> > * 效率高
> >
> > **************
>
> ### gcc链接举例
>
> ```shell
> gcc -O2 -g -o result.out main.c swap.c # -O2 优化等级
> 								    # -g 生成调试信息
> 								    # -o 目标结果文件名
> # 此语句相当于分别将两个'.c' 文件执行预处理、编译、汇编三个过程，在最后一起做重定向
> ```
>
> ### 链接的本质
>
> > #### 本质
> >
> > * 合并相同的 **节**
> >
> > #### 节
> >
> > * text节 - 代表源代码
> > * data节 - 代表已经初始化的数据
> > * bss节 - 代表只声明但是还没初始化的节
> >
> > #### 链接过程
> >
> > * 所有的text节合并成新的text节
> > * 所有的data节合并成新的data节
> > * 所有的bss节合并成新的bss节
> >
> > ***************
>
> ### 可执行文件存储映射
>
> > #### ".o"文件到".out"文件地址变化
> >
> > * ".o"文件里面语句的地址都是从零开始
> > * ".out"文件里面语句地址都不是从零开始
> >
> > #### 上面原因
> >
> > * 经过重定位的可执行文件加入到内存时，加入到的一个虚拟地址空间，32位空间最大4G
> > * 在虚拟地址空间中用户段代码就不是从零开始的
> > * 至于从那里开始，是由ELF头表确定的
> >
> > #### ELF文件
> >
> > * 链接后磁盘中会有此可执行文件的ELF文件
> > * ELF文件组成部分
> >   * ELF头
> >   * 各种节点
> >
> > * 虚拟地址空间源代码分为多段
> > * **只读代码段** —— text、init节点
> > * **读写代码段** —— data、bss节点
> >
> > **************
>
> ### 目标文件
>
> > #### 目标文件定义
> >
> > * 就是二进制机器代码文件
> >
> > * 代码数据地址全都是由零开始的
> > * linux中为 ".o" 文件；Windows中为".obj"文件
> >
> > #### 可执行目标文件
> >
> > * linux中为 ".out" 文件；windows中为 ".exe" 文件
> > * 文件中的代码数据可以直接复制到内存中执行
> > * 代码和数据地址都是虚拟空间的地址
> >
> > #### 共享的目标文件
> >
> > * 是一种特殊的可重定位目标文件
> > * 能在装入或运行时被装入到内存并自动链接
> > * 称为共享库文件
> > * 在linux中是 ".so" 文件；在Windows中为 ".dll"文件
> >
> > #### 目标文件格式
> >
> > * linux中为"ELF" 格式，指可执行、可链接格式
> > * Windows中为"PE"格式，指可移植、可执行格式
> >
> > ***********
>
> ### 链接视图和执行视图
>
> > #### 本质
> >
> > * 两种视图指两类ELF格式
> >
> > #### 链接视图
> >
> > * 用于描述可重定位目标文件
> > * 包含ELF头，程序头表(可选)，各种节
> >
> > #### 执行视图
> >
> > * 用于描述可执行目标文件
> > * 包含ELF头，程序头表(必有)，各种段
> > * 段由多个节映射组成
> >
> > **************
>
> ### 链接视图结构
>
> > #### ELF头
> >
> > * 包含标识信息、文件类型、机器类型、**节头表偏移**等其他信息
> >
> > #### 节头表
> >
> > * 是仅次于ELF头的关键信息
> > * 描述节名、在文件中的**偏移**、**大小**、访问属性、对齐方式等信息
> > * 各个节在ELF文件中的存放位置是根据节的 **偏移、大小**确定的，且偏移的首地址是0x0
> >
> > #### .text节
> >
> > * 编译后的代码部分
> >
> > #### .rodata
> >
> > * 只读部分
> > * 如printf里面的内容、swich跳转表
> >
> > #### .data节
> >
> > * 已初始化的变量
> >
> > #### .bss节
> >
> > * 只声明但未初始化的变量
> >
> > #### .symtab
> >
> > * 符号表
> > * 
> >
> > #### .rel.text节
> >
> > * 一个.text节中的位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置
> >
> > #### .rel.data节
> >
> > * 被模块引用或定义的所有全局变量的重定位信息
> >
> > #### 其他各种各样的节
> >
> > ### 处理核心
> >
> > * 通过ELF头读取到节头表，由节头表就可以读到各种信息
> >
> > *******
>
> ### .symtab结构
>
> > #### 查看符号表
> >
> > ```shell
> > gcc -c main.c -o main.o
> > readelf -s main.o
> > ```
> >
> > #### 结构
> >
> > | Num  | Value | Size | Type     | Bind   | Vis     | Ndx  | Name        |
> > | ---- | ----- | ---- | -------- | ------ | ------- | ---- | ----------- |
> > | 16   | 0x0   | 4    | object   | global | default | 4    | int_a       |
> > | 17   | 0x0   | 4    | object   | global | default | 3    | int_b_init  |
> > | 18   | 0x4   | 1    | object   | global | default | 4    | char_b      |
> > | 19   | 0x4   | 1    | object   | global | default | 3    | char_b_init |
> > | 20   | 0xb2  | 28   | function | global | default | 1    | main        |
> >
> > #### 表项含义
> >
> > * Num —— 代表符号的顺序索引
> > * value —— 代表此符号 **相对于此符号定义的节** 的偏移。16,18是.bss节；17,19是.data节；20是.text节
> > * size —— 此符号定义的object占用的大小或者定义的函数占据的大小
> > * ndx —— 不同整数代表不同的节。4代表bss节；3代表data节；1代表text节
>
> ### 执行视图结构
>
> > #### 执行入口
> >
> > * 链接视图中ELF头的 **e_entry**给出了程序执行第一条指令的地址，且地址为 **0**
> > * 执行视图中ELF头的 **e_entry**同样给出程序执行的第一条指令地址，但 **不为0**
> >
> > #### 其他不同之处
> >
> > * 多一个程序头表
> > * 多一个 ".init" 节
> > * 因为已经是完全链接过的，因此不需要.rel.text和.rel.data节
> >
> > #### 相同之处
> >
> > * 都有节头表
> >
> > * 所有的函数和变量都有确定地址(虚拟地址空间的地址)
> > * 符号引用处已被重定位
> >
> > #### 段
> >
> > * 相同属性的节合并成段
> > * 如.init、.text、.rodata合并成只读代码段
> >
> > #### 程序头表
> >
> > * 说明节如何映射成段
> > * 决定在虚拟地址空间各段的位置信息
> >
> > **************
>
> ### 符号解析
>
> > #### 过程
> >
> > * 程序中有定义和引用的符号
> > * 编译器将定义的符号存放在一个符号表中
> > * 编译器将符号引用存放在重定位中
> > * 链接器将符号引用和符号定义相关联
> >
> > #### 符号类型
> >
> > * 全局符号 —— 非static定义的符号，本模块定义其他模块可以引用
> > * 外部符号 —— extern引入的符号，其他模块定义此模块引用
> > * 局部符号 —— static定义的符号，本模块定义本模块可以引用
> >
> > ### 存储
> >
> > * 存储在**.symtab节**
> > * .symtab节中有符号的各种信息
> >
> > #### 符号表
> >
> > * 只有符号定义才存在符号表
> > * 符号引用不存
> >
> > #### 强弱符号
> >
> > * 强符号 —— 函数定义或已经初始化的变量
> > * 弱符号 —— 未初始化的变量
> >
> > * 强符号指定义且已经有初始值的符号
> > * 弱符号指定义但没有初始值的符号
> > * 规定强符号只能被定义一次，否则链接出错
> > * 一个符号被定义成一次强符号和多次弱符号，则以强符号为准
> > * 若有多个若符号定义，则任选一个
> >
> > #### 注意事项
> >
> > * 两个模块中重复定义 **不同类型**的同一变量时，往往会有意想不到的错误。
> > * 因此尽量避免使用全局变量
> >
> > #### 错误举例
> >
> > ```c
> > /*foo5.c*/
> > void f(void);
> > int y = 15232;
> > int x = 15213;
> > int main(){
> >     f();
> >     printf("%x,%y",x,y);
> >     return 0;
> > }
> > 
> > /*bar5.c*/
> > double x;
> > void f(){x = -0.0;}
> > ```
> >
> > 
>
> >#### 过程
> >
> >* 将多个代码段和数据段合并成一个代码和数据段
> >* 计算每个定义的符号在虚拟地址空间的绝对地址
> >
> >***********
>
> ### 静态库
>
> > #### 静态库概念
> >
> > * 就是平时所说的标准库、公共库、各种库
> >
> > #### 静态库由来
> >
> > * 将所有相关的目标模块(.o)打包成一个单独的库文件(.a)，称为静态库文件，也称为存档文件(archive)
> >
> > #### 静态库使用
> >
> > * 在构建可执行文件时，只需要指定库文件名，链接器自动到库中找用到的目标模块，并且只把用到的模块从库中拷贝出来，链接到可执行文件中
> >
> > ********
>
> ### 符号解析
>
> > #### 静态库调用符号解析
> >
> > * 递归不动点集合解析
> >
> > ### 三个集合
> >
> > * E —— 在最后会被构成可执行文件的文件
> > * U —— 未被解析的符号
> > * D —— 已被解析的符号
> >
> > #### 符号解析算法
> >
> > * 按照顺序扫描 .o和.a文件
> > * .o文件直接放入E，.a文件则进行判断
> > * 扫描期间将未符号引用匹配的符号放入集合U
> > * 在扫描下一个.o或.a文件时进行U集合中符号解析匹配
> > * 若符号A匹配成功则将A从集合E中移除，将A加入集合D，将有A完整定义的文件加入E
> >
> > #### 解析注意事项
> >
> > * 层级越高的文件要放最前面
> > * libc.a文件默认放最后
> >
> > #### 符号解析结果
> >
> > * 集合E —— 使用到的 .o或.a文件
> > * 集合D —— 已解析的符号引用
> >
> > *********
>
> ### 重定位
>
> > #### 步骤
> >
> > * 合并相同的节
> > * 对集合D中的定义符号进行重定位，确定运行时地址
> >
> > #### 重定位条目
> >
> > * 汇编器在遇到引用时，生成一个重定位条目
> > * 数据引用放在 .rel.data节中
> > * 指令中引用放在 .rel.text节中
> >
> > #### 重定条目结构举例
> >
> > * offset ：偏移
> > * symbol：符号名
> > * type：重定位类型。有PC相对寻址和绝对寻址两种
> >
> > **********
>
> ### 重定位实战
>
> > #### 源代码
> >
> > ```c
> > /*main.c*/
> > int sum(int *a, int n);
> > int array[2] = {1,2};
> > void main(){
> > int val = sum(array,2);
> > }
> > 
> > /*sum.c*/
> > int sum(int *a, int n){ return *b+a;}
> > ```
> >
> > #### 带重定位信息的反汇编指令
> >
> > ```shell
> > objdumb -dx main.o > main.s
> > ```
> >
> > #### 反汇编信息
> >
> > ```assembly
> > Disassembly of section .text:
> > 
> > 0000000000000000 <main>:
> > 0:   55                      push   %rbp
> > 1:   48 89 e5                mov    %rsp,%rbp
> > 4:   48 83 ec 10             sub    $0x10,%rsp
> > 8:   be 02 00 00 00          mov    $0x2,%esi
> > d:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 14 <main+0x14>
> >       10: R_X86_64_PC32       array-0x4  #指出array用PC相对寻址重定位
> > 14:   e8 00 00 00 00          callq  19 <main+0x19>
> >       15: R_X86_64_PLT32      sum-0x4    #指出sum用PLT寻址重定位
> > 19:   89 45 fc                mov    %eax,-0x4(%rbp)
> > 1c:   90                      nop
> > 1d:   c9                      leaveq
> > 1e:   c3                      retq
> > 
> > ```
> >
> > * 重定位填入的地址信息就是偏移为0x10和0x15的四个字节
> > * 对array来说
> >   * offset = 0x10
> >   * symbol = array
> >   * type = R_X86_64_PC32
> >   * append = -0x4
> >
> > #### 寻址方式
> >
> > * PC相对寻址 —— 地址 = 下一条指令的地址(PC的值) + 偏移
> > * 绝对寻址 —— 地址 = 绝对地址
> >
> > #### 相对寻址重定位过程
> >
> > * 符号解析完成后E中肯定有main.o和sum.o两个文件；D中肯定有sum符号
> > * 代码合并后main和sum在同一个.text节中
> > * 在.text节中根据重定位条目信息进行相对寻址重定位 
> >
> > #### 绝对寻址重定位过程
> >
> > * 符号解析完成代码合并后.data节中一定有array的位置信息
> > * 在.text节中根据.data节中array的绝对地址进行绝对地址重定位
> >
> > *******
>
> ### 可执行文件
>
> > #### 查看程序头部表(program header table)
> >
> > ```shell
> > objdump -dx main_sum.out > main_sum.out.s
> > ```
> >
> > #### 程序头部表内容
> >
> > ```shell
> > LOAD 	 off  0x0000000000000000  #偏移
> > 		vaddr 0x0000000000000000    #内存地址
> > 		paddr 0x0000000000000000    #内存地址
> > 		align 2**21                 #对齐方式
> > filesz 0x0000000000000830   #目标文件段大小
> > memsz 0x0000000000000830    #内存中段大小
> > flags r-x                   #代码段读写标志位
> > LOAD 	 off  0x0000000000000df0 
> > 		vaddr 0x0000000000200df0 
> > 		paddr 0x0000000000200df0 
> > 		align 2**21
> > filesz 0x0000000000000228 
> > memsz 0x0000000000000230 
> > flags rw-                   #data段读写标志位
> > ```
> >
> > * .data段包含.data节和.bss节，因为有一些变量未被初始化未分配空间。因此.data段目标文件段大小和内存中段大小不一样
> >
> > #### 查看ELF头表
> >
> > ```shell
> > readelf -h main_sum.out
> > ```
> >
> > #### ELF头表内容
> >
> > ```assembly
> > ELF Header:
> >   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
> >   Class:                             ELF64
> >   Data:                              2's complement, little endian
> >   Version:                           1 (current)
> >   OS/ABI:                            UNIX - System V
> >   ABI Version:                       0
> >   Type:                              DYN (Shared object file)
> >   Machine:                           Advanced Micro Devices X86-64
> >   Version:                           0x1
> >   Entry point address:               0x4f0   #程序main()函数的入口
> >   Start of program headers:          64 (bytes into file)
> >   Start of section headers:          6472 (bytes into file)
> >   Flags:                             0x0
> >   Size of this header:               64 (bytes)
> >   Size of program headers:           56 (bytes)
> >   Number of program headers:         9
> >   Size of section headers:           64 (bytes)
> >   Number of section headers:         28
> >   Section header string table index: 27
> > ```
> >
> > * entry point规定了程序的入口
> >
> > ********
>
> #### 加载可执行文件
>
> > #### 加载定义
> >
> > * 将程序复制到内存中并运行的过程
> >
> > #### 加载粗过程
> >
> > * 系统调用execve()调用加载器
> > * 加载器加载可执行文件
> >
> > #### execv()过程
> >
> > * 在shell命令行输入命令
> > * 命令行解释器对命令行输入做切分，分出调用程序名和参数
> > * 调用fork()函数，几乎百分百赋值一个和父进程一模一样的进程。包括只读代码段、读写代码段、堆、用户栈
> > * 调用execv()函数，删除新进程赋值的现有虚拟内存段，并创建被调用进程的虚拟内存段
> > * 调用进程的main函数
> > * 返回并归还系统控制权
> >
> > #### 虚拟内存
> >
> > * 加载后代码和数据段被映射到虚拟地址空间
> >
> > ***************
>
> ### 共享库
>
> > #### 特点
> >
> > * 每个库包含目标代码文件
> > * 从程序中分离出来，**无论磁盘还是内存** 都只有一份
> > * 可以在运行时和加载时动态链接
> >
> > ******
>
> ### 动态链接
>
> > #### 动态链接定义
> >
> > * 在加载时或运行时，共享库可以被加载到任意的内存地址，并和一个在内存中的程序链接起来
> >
> > #### 动态链接运用举例
> >
> > * Windows更新
> > * 高性能web服务器
> > * 共享库可以用不同语言开发
> > * 共享库可以作为插件，拓展程序的功能
> >
> > #### 动态链接好处
> >
> > * 可以动态进行链接，随增随减
> > * 而且可以不在编译的时候链接，而在加载和运行时链接
> >
> > #### load time linking
> >
> > * 使用动态链接器进行链接(Id-linux.so)
> >
> > #### run time linking
> >
> > * 调用dlopen()接口来实现
> > * 可用于构建高性能web服务器
> >
> > #### 动态链接过程
> >
> > * main.o，libc.so先进行静态链接生成main.out。但此main.out只是部分链接的可执行文件
> > * main.out加载执行时调用execv()系统调用
> > * execv()调用动态链接器Id-linux.so进行动态链接，生成完全链接的可执行目标。但此目标只存在于存储空间而不存在于磁盘空间
> >
> > #### 程序头表
> >
> > * 可执行文件中的程序头表中有指明动态链接器的路径。此种链接应该是加载时链接而非运行时链接
> >
> > ***********
>
> ### 位置无关代码
>
> > #### 生成位置无关代码共享库
> >
> > ```shell
> > gcc -shared -fPIC lib.so sum.o sub.o
> > ```
> >
> > #### PIC特点
> >
> > * 共享库代码被加载到内存的位置可以是不确定的
> > * 即使共享库代码长度发生改变，也不影响调用它的程序
> >
> > #### 引入PIC目的
> >
> > * 无需修改程序代码即可将共享库加载到任意位置执行
> >
> > #### 模块内部函数调用或跳转
> >
> > * 使用PC相对寻址
> > * 寻址的偏移量是补码表示，可以为负数
> > * 此调用无需动态链接器参与，因为根本没有涉及其他模块
> >
> > #### 模块内部数据引用
> >
> > * 对于模块内部的static变量，它是被存储在.data段中的
> > * 访问它依旧采取PC相对寻址
> > * 但偏移量有变化。偏移=下一条指令到.text段结尾的偏移 + .data段起始位置到变量位置的偏移
> > * 等于偏移等于两段偏移的和
> > * 因为没涉及其他模块，因此也不用动态链接
> >
> > #### PIC模块外数据引用
> >
> > * 在.data节开始处设置一个指针数组(全局偏移表，GOT)，指针可指向一个非静态全局变量
> > * GOT条目与引用数据的指令之间的距离相对固定。和上面一种情况一样
> > * 汇编器为GOT的每一项生成一个重定位项(在.rel.data中)
> > * 加载时，动态链接器对GOT中的每一项进行重定位，填入所引用的地址(如&b )
> > * 等于是PC相对先找到GOT中的项，GOT项的值就是变量的真实地址，而GOT项的值是动态链接时填入的
> >
> > #### PIC模块之间进行调用或跳转
> >
> > * 和上一种方式一样
> > * 只不过GOT表项的值为函数的首地址
> > * 可以使用延迟绑定技术 —— 即加载时不绑定而是第一个运行调用时才绑定
> >
> > #### PIC缺点
> >
> > * 一次访问或跳转使用更多的指令条数和寄存器数量
> >
> > *************
>
> ### 打桩机制
>
> > #### 打桩解释
> >
> > * 替换动态链接中的方法或函数实现
> >
> > #### 编译时打桩
> >
> > * 使用 '-I' 参数告诉预处理器前扫描前首先在当前目录寻找.h定义
> >
> > #### 链接时打桩
> >
> > * 使用'--wrap'实现符号的重命名进行打桩
> >
> > #### 运行时打桩
> >
> > * 动态链接器'LD_PRELOAD'环境变量设置一些共享库路径名
> > * 当有未解析的符号时首先就在设置的路径名中找，从而实现打桩
> >
> > #### 打桩核心
> >
> > * 让自己编写的函数体被解析的优先级比原先的优先级高
> >
> > ****************

## 第八章

> ### 异常
>
> > #### 定义
> >
> > * 异常就是控制流的突变，用来响应处理器状态中的某些变化
> >
> > #### 处理
> >
> > * 检测到异常发生
> > * 通过异常跳转表，进行一个间接过程调用
> > * 跳转到异常处理程序
> >
> > #### 结果
> >
> > * 控制返回给current指令
> > * 控制返回给next指令
> > * 程序被中断
> >
> > #### 误区
> >
> > * 异常并不是错误
> > * 造成控制流突变的都是异常
> >
> > ********
>
> ### 异常处理
>
> > #### 异常号
> >
> > * 异常号是一些非负整数
> > * 一部分由处理器设计者决定。如缺页、被零除外部IO
> > * 一部分由操作系统内核(操作系统常驻内存的部分)设计者决定。如系统调用、外部IO等
> >
> > #### 异常表
> >
> > * 插电时进行初始化
> > * 异常表基地址存在一个异常基址寄存器中
> >
> > #### 与过程调用联系
> >
> > * 两者非常类似
> > * 但有很多不同
> >
> > *********
>
> ### 异常类别
>
> > #### 类别表
> >
> > | 类型 | 原因             | 异/同 | 返回       |
> > | ---- | ---------------- | ----- | ---------- |
> > | 中断 | 设备IO信号       | 异步  | 下一条指令 |
> > | 陷阱 | 有意的异常       | 同步  | 下一条指令 |
> > | 故障 | 潜在可恢复的错误 | 同步  | 当前指令   |
> > | 终止 | 不可恢复的错误   | 同步  | 不返回     |
> >
> > #### 陷阱和系统调用
> >
> > * 陷阱最重要的用途就是在用户程序和内核之间提供一个像过程一样的接口 —— 系统调用
> > * read、fork、execve、exit都是系统调用
> > * 系统调用和调用过程很类似，但也有很多不同
> >
> > #### 故障
> >
> > * 故障举例 ——缺页
> > * 故障要么返回到当前指令、要么直接终止
> >
> > *************
>
> ### linux 系统调用
>
> > #### 基础
> >
> > * 内核中有一个系统调用跳转表，此跳转表和异常表没有关系
> > * C语言提供了包含了系统调用整数参数的系统级函数
> >
> > #### 系统调用函数底层
> >
> > * 用rax寄存器来传递调用了系统调用整数值
> > * 参数还是依次放在 %rdi、%rsi中
> >
> > #### 举例
> >
> > ```c
> > void main(){
> >         write(1,"Hello World\n",12);//参数1代表stdout，参数2是内容，参数3是长度
> >         _exit(0);
> > }
> > ```
> >
> > #### 标准输入输出
> >
> > * stdin —— 0
> > * stdout —— 1
> > * stderr —— 2
> >
> > ****************
>
> ### 名词解释
>
> > #### 进程
> >
> > * 最核心的认识是好像 **独占**
> > * 独占处理器、内存
> > * 系统中的每个程序都运行在某个进程的上下文中
> >
> > #### 上下文
> >
> > * 上下文是程序正确运行所需的状态组成
> > * 包括代码、数据、寄存器内容、程序计数器、栈、环境变量
> >
> > #### 逻辑控制流
> >
> > * 程序计数器PC值的序列就是逻辑控制流
> >
> > #### 并发
> >
> > * 两个逻辑流同时发生
> > * **要求两个流分别的开始和结束时间的交集不为空**
> >
> > #### 多任务
> >
> > * 多个进程轮流执行
> >
> > #### 并行
> >
> > * 两个流并发地运行在不同的处理器核或者计算机上
> >
> > #### 内核和用户模式
> >
> > * 用户模式当且仅当通过中断、故障、陷阱系统调用异常进入内核模式
> >
> > #### 上下文切换
> >
> > * 切换由 **操作系统内核** 来完成
> >
> > **********
>
> ### 信号
>
> > #### 概念
> >
> > * 信号 一种更高层次的软件形式异常
> >
> > #### 发送信号
> >
> > * 发送者 —— 操作系统内核
> > * 发送信号两者情况
> >   * 内核检测到一个系统事件
> >   * 一个进程调用了kill函数
>
> ************

## 第九章

> ### 概述
>
> > #### 作用
> >
> > * 为每个进程提供了一个大的、一致的、私有的地址空间
> >
> > #### 功能
> >
> > * 将主存看作是一个存储在硬盘上的地址空间的高速缓存
> > * 为每个进程提供一致的地址空间
> > * 保护每个进程的地址空间不被其他进程破坏
> >
> > ***************
>
> ### 早期内存管理
>
> > #### 早期程序员
> >
> > * 需要自己手动管理内存
> > * 此程序占据分配那一段内存是在程序员自己定的
> > * 程序源代码中还包含大量内存换进换出的复杂代码
> >
> > #### 向虚拟演化
> >
> > * 鉴于上面的情况
> > * 开始把程序写在虚拟地址空间，而程序实际跑在物理主存空间
> > * 由此就有一个虚拟到实际的映射
> >
> > *********************
>
> ### 早期分页管理
>
> > #### 虚拟地址空间
> >
> > * 程序写在此虚拟地址空间上
> > * 又叫做逻辑地址空间
> > * 内存存储在最慢的磁盘上
> > * 假设此虚拟地址空间有16位。即容量为64KB
> >
> > #### 物理地址空间
> >
> > * 就是主存地址空间
> > * 但此主存容量较小，地址空间只有12位。即容量为4KB
> >
> > #### 分页实现准备
> >
> > * 设页大小为4KB
> > * 这样虚拟地址空间总容量为16个页大小
> >
> > #### 0 - 4096-1访问
> >
> > * 此时把逻辑地址空间0 - 4096-1 从硬盘调入主存中
> > * 开始一一对应访问
> >
> > #### 4096- - 8192-1访问
> >
> > * 此时把逻辑地址空间4096 - 8192-1 从硬盘调入主存中
> > * 4096对应物理地址0，8192-1对应物理地址4096-1
> >
> > #### 名词由来
> >
> > * 把此固定的区间称为页
> > * 把主存中存放页的区域称为页框，早期主存只有一个页框，即4KB
> >
> > ***********************
>
> ### 现代分页思想
>
> > #### 分页思想
> >
> > * 主存物理空间被分成页 —— 实页
> > * 进程逻辑空间也被划分成页 ——虚页
> > * 虚页可以装入实页中
> > * 很多个连续的虚页在主存中可以不连续，可以进行离散
> > * 操作系统为每个进程都生成一个页表
> > * 通过这个页表就能实现虚拟地址空间向物理地址空间的映射
> >
> > #### 特点
> >
> > * 无论是虚页还是实页，页内偏移不变。因为它们的页大小及各种特点都是一样的
> >
> > *********
>
> ### 物理和虚拟寻址
>
> > #### 物理寻址
> >
> > * CPU直接请求物理地址，在内存数组上取内容
> >
> > #### 虚拟寻址
> >
> > * CPU请求一个虚拟地址
> > * 虚拟地址通过MMU(CPU中的内存管理单元)映射翻译成物理地址
> > * 根据翻译而来的物理地址去物理空间寻找
> >
> > **************
>
> ### 基本思想与实质
>
> > #### 基本思想
> >
> > * 地址空间区分了数据对象(字节)和它们的属性(地址)
> > * 有不同的地址空间，同一个数据对象就能有多个属性(地址)
> > * 主存中的每个字节都有一个来源于虚拟地址空间的虚拟地址和一个来源于实际物理空间的物理地址
> >
> > #### 实质
> >
> > * 允许程序员在一个很大很大的逻辑虚拟地址空间中进行编程
> > * 实际执行时按需调入页，而不是全部装入
> > * 指令执行时进行两种地址的翻译
> > * 发生缺页时由操作系统来处理
> >
> > ***********
>
> ### 虚拟地址空间
>
> > * 实际上就是顶层为内核代码，底层为不可用区域的那个结构
>
> ### 页表结构
>
> > #### 页表部分项
> >
> > * 装入位 —— 1代表已经装入内存，0代表还在磁盘上未装入内存
> > * 修改位 —— 脏位，代表是否被修改。用于写回判断
> > * 实页号 —— 对应主存的页框号
> >
> > #### 页表属性
> >
> > * 对于32位系统而言，页大小为4KB，则32位地址空间有1MB项个页面
> > * 假定一个页项占4B，则页大小就是4MB。已经很大了
> > * 页表存在虚拟地址空间的内核区
> > * 访问页表也需要分页，简直就是套娃
> >
> > #### 页表项状态
> >
> > * 未分配页 —— 就是虚拟地址空间中的空页，啥内容都没有
> > * 已分配的缓存页 —— 主存已装入的页
> > * 已分配未缓存页 —— 主存未装入的页
> >
> > *********
>
> ### 地址转化
>
> > #### 准备概念
> >
> > * 页表存放位置 —— **主存**中
> > * 页表的地址 —— 页基址寄存器
> > * 虚拟地址结构 —— 页表索引 + 页内偏移
> > * 物理地址结构 —— 物理页框索引 + 页内偏移
> >
> > #### 访问过程
> >
> > * 页基址寄存器 + 页表索引*页表项大小得到对应的页表项
> > * 检查是否已经装入主存，如果装入则执行下面操作
> > * 将虚拟地址中的页表索引替换成页表项中的物理页框号得到物理地址
> > * 根据物理地址进行实际访问
> >
> > #### 可能出现的问题
> >
> > * 缺页
> > * 页表项中明确此页禁止写入但执行写入操作发生保护违例
> >
> > #### 缺页处理
> >
> > * 由操作系统进行缺页处理
> > * 缺页的进程会直接被阻塞挂起
> >
> > #### 保护违例成处理
> >
> > * 直接终止进程
> >
> > *************
>
> ### TLB
>
> > #### 产生原因
> >
> > * 为了减少访问主存的次数
> > * 相当于是主存中整个4M大的页表的一个子集
> >
> > #### TLB结构
> >
> > * Tag —— 标记
> > * 页框号 —— 主存中的页框号
> >
> > #### 全相联TLB访问过程
> >
> > * 首先将虚拟地址的tag和TLB所有tag比较
> > * 如果有一样的就直接取出页框号拼出物理地址
> > * 如果没有就去主存中的页表找
> >
> > **********
>
> ### 整个存储访问过程
>
> > #### 最好情况
> >
> > * CPU请求一个虚拟地址
> > * 去TLB中查，命中，得到物理地址
> > * 根据物理地址去Cache中找，命中，得到实际内容
> >
> > #### 次好情况
> >
> > * CPU请求一个虚拟地址
> > * 去TLB中查，失败
> > * 去页表中查，命中，得到物理地址
> > * 根据物理地址去Cache中找，命中，得到实际内容
> >
> > #### 最坏情况
> >
> > * CPU请求一个虚拟地址
> > * 去TLB中查，失败
> > * 去页表中查，失败
> > * 缺页
> >
> > #### 注意
> >
> > * 上述情况未讨论cache缺失未命中的情况
> >
> > #### TLB组相联虚拟地址结构
> >
> > * tag
> > * index
> > * bias
> > * 其中tag + index肯定等于20位，bias是12位。index由组数决定
> >
> > **********
>
> ### 虚拟内存优势
>
> > #### 简化链接
> >
> > * 虚拟地址空间结构是一致的，是独立于物理内存的
> > * 因此一致的虚拟地址结构可以简化链接
> >
> > #### 简化加载
> >
> > * 加载的时候从来不会从磁盘复制内容到内存
> > * 都是初始化页表，把页表全标记为未缓存
> > * 这样程序执行时会自动因为页表不命中而加载
> >
> > #### 简化共享
> >
> > * 不同进程的页表的项指向同一个物理页就实现了共享
> >
> > #### 简化内存分配
> >
> > * 内存分配就是在虚拟地址空间中无效根本未用的连续分配虚拟页
> > * 分配后就不用管了，会自动未命中加载入主存
> >
> > #### 保护内存
> >
> > * 通过在页表项中添加属性就能实现保护内存读写
> >
> > *************
>
> ### 多级页表
>
> > #### 作用
> >
> > * 32位系统页表就有4M大，更不要说64位的系统
> > * 每个进程都有一个页表常驻内存，内存开销太大
> >
> > #### 实现
> >
> > * 使用多级页表
> > * 首先一级页表每个项代表很大的空间
> > * 当一级页表某一项根本没被访问时，对应的低级页表根本不会出现
> >
> > #### 结果
> >
> > * 只有一级页表常驻内存，其他页表需要时才载入
> > * 一级页表为null未命中，那么二级页表根本不会存在
> >
> > ************
>
> ### linux虚拟内存系统
>
> > #### 内核区
> >
> > * 包含内核代码和内核数据结构
> > * 通过所有进程虚拟内存映射到主存同一区域实现共享
> >
> > #### 组织虚拟内存
> >
> > * 通过一个链
> > * 链的每一个节点都代表虚拟内存的一个段
> > * 这样的组织方式就可以不用管那些根本没有用的虚拟内存以及段之间的空隙
> >
> > #### 缺页异常处理
> >
> > * 访问一个不存在的页面(指不在虚拟内存段链表区域的内存)
> > * 正常缺页
> > * 保护违例
> >
> > ************
>
> ### 内存映射
>
> > #### 概述
> >
> > * linux通过将虚拟内存的一个区域与磁盘上的一个对象关联起来
> > * 关联的目的是初始化这个虚拟内存区域的内容
> >
> > #### 核心
> >
> > * 实质上是第一次访问缺页时，该把硬盘那个位置的换入内存
> >
> > #### 映射的两种对象
> >
> > * linux普通文件
> > * linux匿名文件
> >
> > #### 结果
> >
> > * 虚拟页面在交换文件之间换来换去
> >
> > **********
>
> ### 在看共享对象
>
> > #### 共享对象是什么
> >
> > * 共享对象指的是虚拟内存内存初始化映射到的linux文件
> >
> > #### 公有共享对象
> >
> > * 磁盘只有一个对象源文件
> > * 物理内存只有一个副本
> > * 不同进程虚拟内存映射到相同的共享对象。页表在映射到相同的物理内存
> >
> > #### 私有共享对象
> >
> > * 总体和公有差不多
> > * 只不过在写操作时会触发写时赋值保护程序
> >
> > *******
>
> #### 在看fork函数
>
> > #### 执行过程
> >
> > * 拷贝mm_struct、区域结构表、页表的副本
> > * 将两个进程共享的页面设置成只可读
> > * 将区域结构标记设置成写时赋值
> >
> > #### 写时赋值核心思想
> >
> > * 写前
> >   * 两个进程虚拟内存的两个区域映射到物理内存的相同区域
> >   * 区域结构被标记为写时复制
> > * 写时
> >   * 假设进程2执行写操作
> >   * 进程2所写的物理页面进行复制，复制一个副本到物理内存的其他区域
> >   * 进程2的页表发生改变，进程1的页表不变
> >   * 进程2执行写操作
> > * 写后
> >   * 进程1虚拟内存映射的物理内存内容和原来是一样的
> >   * 进程2虚拟内存映射的物理内存内容和原来不一样了
> >
> > #### 核心
> >
> > * fork完后子和父进程的虚拟空间，页表是完全一样的
> > * 正是因此写时赋值的机制才能让子进程发生改变，而父进程不变
> > * 写时复制为每个进程保持了私有地址空间的抽象概念
> >
> > ***********
>
> ### 在看execv函数
>
> > #### 目的
> >
> > * 用新进程替换当前进程
> >
> > #### 删除用户区域
> >
> > * 将虚拟地址空间中的用户栈、堆空间请求二进制零
> >
> > #### 映射私有区域
> >
> > * 代码、初始化数据映射成新进程可执行文件的代码数据部分
> > * 未初始化数据部分虚拟页面请求二进制零
> >
> > #### 映射共享区域
> >
> > * 共享库动态链接
> >
> > #### 设置PC
> >
> > * 将PC设置成程序入口
> >
> > *******
>
> #### mmap函数
>
> > #### 作用
> >
> > * 用户自己创建新的虚拟内存区域，并将自定义对象映射到新创建的虚拟内存区域中
> >
> > ****************
>
> ### 动态内存分配
>
> > #### 分配位置
> >
> > * 进程虚拟空间的堆中
> >
> > #### 管理者
> >
> > * 动态内存分配器
> >
> > #### 堆
> >
> > * 初始化是请求二进制零
> > * 内核维护一个brk变量指向堆顶
> >
> > #### 分配器工作
> >
> > * 将堆视作一组大小不同的块集合
> > * 对这些块集合进行管理
> >
> > #### 分配器种类
> >
> > * 显式分配器 —— 类似maloc函数和free函数
> > * 隐式分配器 —— 类似gc
> >
> > #### 使用动态分配原因
> >
> > * 直到程序运行时，才知道某些数据结构的大小
> >
> > ********
>
> ### malloc函数和free函数
>
> > #### molloc实现方式
> >
> > * 通过mmap和munmap函数
> > * 通过sbrk函数
> >
> > #### sbrk实现原理
> >
> > * 通过改变指向堆顶的指针变量brk的值来分配内存
> >
> > *******
>
> ### 分配器目标
>
> > #### 吞吐率
> >
> > * 指单位时间进行分配和释放操作的能力
> >
> > #### 内存利用率
> >
> > * 指虚拟内存的空间利用率
> >
> > #### 关系
> >
> > * 两者成常常是反比关系
> >
> > **********
>
> ### 垃圾收集机制
>
> > #### 可达图实现原理
> >
> > * 将内存视作一个可达图
> > * 可达图的边由各种引用、全局声明等其他信息表明
> > * 图的一个结点就是一个已分配的内存块
> > * 当可达时不是垃圾，不可达时是垃圾
> >
> > #### 不同语言区别
> >
> > * java这种语言能够精确表达可达，因而垃圾回收机制强
> > * 而c、c++原因不能精确表示，因而垃圾回收机制弱
> >
> > #### Mark & Sweep实现原理
> >
> > * 标记过程从根节点递归标记所有可达已分配的后继
> > * 清楚过程就清除未被标记的垃圾块
> >
> > *************
>
> ### 常见内存错误
>
> > #### 引用坏指针
> >
> > * 引用到虚拟地址空间中没有映射到任何物理内存的页
> > * 引用到只读页但进行写操作
> > * 举例 —— scanf函数传整数的地址结果传成了整数而导致引用坏指针
> >
> > #### 读未初始化内存
> >
> > * 堆内存分配后未进行初始化，不能默认堆内存初始化为0，要手动进行初始化
> >
> > #### 假设指针和它指向对象是相同大小
> >
> > ```c
> > int **a = (int **)malloc(n*sizeof(int)); //此写法错误，应改成下面写法
> > int **a = (int **)malloc(n*sizeof(int *));
> > ```
> >
> > #### 误解指针运算
> >
> > * 指针运算的大小是它指向的对象而不是字节
> >
> > #### 引用不存在的变量
> >
> > * 变量未被初始化未分配内存就引用它的地址
> >
> > #### 内存泄漏
> >
> > * malloc了内存过后却不释放，导致堆空间溢出

## 作业

> ### 2.55
>
> ```c
> #include<stdio.h>
> 
> typedef unsigned char* byte_pointer; //typedef不用加#，且末尾必须要加分号
> 
> void main(){
> int x=0x00323130;
> show_int(x);
> }
> 
> /*要打印每个字节只能使用char指针，因为只有它每偏移一位是一个字节*/
> void show_bytes(const char *s,size_t length){
> size_t i=0;
> for(i;i<length;i++){
> 	//'%.2x'表示输出十六进制且高位为0保留
> printf("%.2x ",s[i]);
> }
> printf("\n");
> 	/*字符串结尾字节以0结束，0x00323130的位表示可以解释成字符串，恰好是012*/
> printf("output by char*:  %s\n",s); 
> }
> 
> void show_int(int x){
> 	//转换成char*指针就可以按照字节读取
> show_bytes((const char *)(&x),sizeof(int));
> }
> 
> ```
>
> ### 2.58
>
> ```c
> #include<stdio.h>
> 
> void main(){
> is_little_end();
> }
> 
> void is_little_end(){
> int x=1;
> const char first_byte=*((const char *)(&x));
> //C语言不支持bool类型，C++才支持，就离谱
> if(first_byte!=0)
> printf("is little end: true");
> else
> printf("is little end: false");
> printf("\n");
> }
> ```
>
> ### 2.59
>
> ```c
> #include<stdio.h>
> 
> void main(){
> int x=0x89ABCDEF;
> int y=0x76543210;
> printf("%x",swap((const char *)&x,(char *)&y));
> printf("\n");
> }
> 
> //因为要在函数内部修改指针指向的值，因此y不能是const
> int swap(const char *x,char *y){
> *y=*x;
> return *((const int *)y);
> }
> ```
>
> ************



## 代码bug和笔记

> ### 指针使用
>
> ```c
> #include<stdio.h>
> void main(){
> 	//指针必须分配内存后才能使用，指针的声明是不知道它指向那里的
> int *x=(int *)malloc(4);
> *x=3;
> printf("%d\n",*x);
> }
> ```
>
> ### 引入.h文件
>
> ```c++
> #include<stdio.h>
> int main(){
> printf("Hello World");
> }
> ```
>
> * 必须引入 stdio.h 头文件有printf的定义才能进行重定向绑定
>
> ***************

## 第十章

> ### unix I/O
>
> > #### I
> >
> > * 代表输入，从IO设备复制数据到主存
> >
> > #### O
> >
> > * 代表输出，从主存复制数据到IO设备
> >
> > #### 文件描述符
> >
> > * 打开文件操作内核返回一个小的非负数整数，称为描述符
> > * 内核记录有关这个打开文件的信息
> > * 应用程序只需要记住描述符
> >
> > #### 描述符举例
> >
> > * 0 —— 标准输入
> > * 1 —— 标准输出
> > * 2 —— 标准错误
> >
> > #### 改变文件位置
> >
> > * 内核保持着每个文件的位置k
> > * k初始为0
> > * 应用程序通过seek操作显示改变文件位置k
> >
> > #### 读写文件
> >
> > * 从当前位置k开始复制出或者复制入字节
> > * 读文件会触发EOF操作
> >
> > #### 关闭文件
> >
> > * 内核释放打开文件而创建的数据结构
> > * 把文件描述符归还到文件描述符成池
> >
> > *************
>
> ### 文件
>
> > #### 普通文件
> >
> > * 分为文本文件和二进制文件，但内核不区分这两种文件
> > * 文本文件的换行符和ASCII码是一样的
> >
> > #### 目录文件
> >
> > * 目录文件实际上是包含一组链接的文件
> > * 每个链接都将一个文件名映射到一个文件或者文件夹
> > * .是目录到自身的链接
> > * ..是目录到父目录的链接
> >
> > #### 套接字文件
> >
> > * 用来与另一个进程进行跨网络通信的文件
> >
> > #### 其他文件
> >
> > * 如通道、链接
> >
> > **********
>
> ### 打开和关闭文件
>
> > #### 打开文件
> >
> > ```c
> > int open(char *filename, int flags, mode_t mode)
> > ```
> >
> > * 调用open函数
> > * 将filename转换为文件描述符并返回文件描述符
> >
> > #### 关闭文件
> >
> > ```c
> > int close(int fd)
> > ```
> >
> > #### 读文件
> >
> > ```c
> > ssize_t read(int fd, void *buf, size_t n);
> > ```
> >
> > * 从文件描述符为fd的文件当前位置复制最多n个字节内容到内存buf位置
> >
> > #### 写文件
> >
> > ```c
> > ssize_t write(int fd, const void *buf, size_t n)
> > ```
> >
> > * 从内存buf处复制最多n个字节内容到文件描述符为fd的文件的当前位置